{"version":3,"file":"plugin.js","sources":["../../../../src/utils.ts","../../../../node_modules/@orchidjs/unicode-variants/dist/esm/index.js","../../../../src/vanilla.ts","../../../../src/plugins/checkbox_options/plugin.ts"],"sourcesContent":["\r\nimport TomSelect from './tom-select';\r\nimport { TomLoadCallback } from './types/index';\r\n\r\n\r\n/**\r\n * Converts a scalar to its best string representation\r\n * for hash keys and HTML attribute values.\r\n *\r\n * Transformations:\r\n *   'str'     -> 'str'\r\n *   null      -> ''\r\n *   undefined -> ''\r\n *   true      -> '1'\r\n *   false     -> '0'\r\n *   0         -> '0'\r\n *   1         -> '1'\r\n *\r\n */\r\nexport const hash_key = (value:undefined|null|boolean|string|number):string|null => {\r\n\tif (typeof value === 'undefined' || value === null) return null;\r\n\treturn get_hash(value);\r\n};\r\n\r\nexport const get_hash = (value:boolean|string|number):string => {\r\n\tif (typeof value === 'boolean') return value ? '1' : '0';\r\n\treturn value + '';\r\n};\r\n\r\n/**\r\n * Escapes a string for use within HTML.\r\n *\r\n */\r\nexport const escape_html = (str:string):string => {\r\n\treturn (str + '')\r\n\t\t.replace(/&/g, '&amp;')\r\n\t\t.replace(/</g, '&lt;')\r\n\t\t.replace(/>/g, '&gt;')\r\n\t\t.replace(/\"/g, '&quot;');\r\n};\r\n\r\n\r\n/**\r\n * use setTimeout if timeout > 0 \r\n */\r\nexport const timeout = (fn:()=>void,timeout:number) => {\r\n\tif( timeout > 0 ){\r\n\t\treturn setTimeout(fn,timeout);\r\n\t}\r\n\r\n\tfn.call(null);\r\n\treturn null;\r\n}\r\n\r\n/**\r\n * Debounce the user provided load function\r\n *\r\n */\r\nexport const loadDebounce = (fn:(value:string,callback:TomLoadCallback) => void,delay:number) => {\r\n\tvar timeout: null|ReturnType<typeof setTimeout>;\r\n\treturn function(this:TomSelect, value:string,callback:TomLoadCallback) {\r\n\t\tvar self = this;\r\n\r\n\t\tif( timeout ){\r\n\t\t\tself.loading = Math.max(self.loading - 1, 0);\r\n\t\t\tclearTimeout(timeout);\r\n\t\t}\r\n\t\ttimeout = setTimeout(function() {\r\n\t\t\ttimeout = null;\r\n\t\t\tself.loadedSearches[value] = true;\r\n\t\t\tfn.call(self, value, callback);\r\n\r\n\t\t}, delay);\r\n\t};\r\n};\r\n\r\n\r\n/**\r\n * Debounce all fired events types listed in `types`\r\n * while executing the provided `fn`.\r\n *\r\n */\r\nexport const debounce_events = ( self:TomSelect, types:string[], fn:() => void ) => {\r\n\tvar type:string;\r\n\tvar trigger = self.trigger;\r\n\tvar event_args:{ [key: string]: any } = {};\r\n\r\n\t// override trigger method\r\n\tself.trigger = function(){\r\n\t\tvar type = arguments[0];\r\n\t\tif (types.indexOf(type) !== -1) {\r\n\t\t\tevent_args[type] = arguments;\r\n\t\t} else {\r\n\t\t\treturn trigger.apply(self, arguments);\r\n\t\t}\r\n\t};\r\n\r\n\t// invoke provided function\r\n\tfn.apply(self, []);\r\n\tself.trigger = trigger;\r\n\r\n\t// trigger queued events\r\n\tfor( type of types ){\r\n\t\tif( type in event_args ){\r\n\t\t\ttrigger.apply(self, event_args[type]);\r\n\t\t}\r\n\t}\r\n};\r\n\r\n\r\n/**\r\n * Determines the current selection within a text input control.\r\n * Returns an object containing:\r\n *   - start\r\n *   - length\r\n *\r\n * Note: \"selectionStart, selectionEnd ... apply only to inputs of types text, search, URL, tel and password\"\r\n * \t- https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/setSelectionRange\r\n */\r\nexport const getSelection = (input:HTMLInputElement):{ start: number; length: number } => {\r\n\treturn {\r\n\t\tstart\t: input.selectionStart || 0,\r\n\t\tlength\t: (input.selectionEnd||0) - (input.selectionStart||0),\r\n\t};\r\n};\r\n\r\n\r\n/**\r\n * Prevent default\r\n *\r\n */\r\nexport const preventDefault = (evt?:Event, stop:boolean=false):void => {\r\n\tif( evt ){\r\n\t\tevt.preventDefault();\r\n\t\tif( stop ){\r\n\t\t\tevt.stopPropagation();\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * Add event helper\r\n *\r\n */\r\nexport const addEvent = (target:EventTarget, type:string, callback:EventListenerOrEventListenerObject, options?:object):void => {\r\n\ttarget.addEventListener(type,callback,options);\r\n};\r\n\r\n\r\n/**\r\n * Return true if the requested key is down\r\n * Will return false if more than one control character is pressed ( when [ctrl+shift+a] != [ctrl+a] )\r\n * The current evt may not always set ( eg calling advanceSelection() )\r\n *\r\n */\r\nexport const isKeyDown = ( key_name:keyof (KeyboardEvent|MouseEvent), evt?:KeyboardEvent|MouseEvent ) => {\r\n\r\n\tif( !evt ){\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif( !evt[key_name] ){\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvar count = (evt.altKey?1:0) + (evt.ctrlKey?1:0) + (evt.shiftKey?1:0) + (evt.metaKey?1:0);\r\n\r\n\tif( count === 1 ){\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n};\r\n\r\n\r\n/**\r\n * Get the id of an element\r\n * If the id attribute is not set, set the attribute with the given id\r\n *\r\n */\r\nexport const getId = (el:Element,id:string) => {\r\n\tconst existing_id = el.getAttribute('id');\r\n\tif( existing_id ){\r\n\t\treturn existing_id;\r\n\t}\r\n\r\n\tel.setAttribute('id',id);\r\n\treturn id;\r\n};\r\n\r\n\r\n/**\r\n * Returns a string with backslashes added before characters that need to be escaped.\r\n */\r\nexport const addSlashes = (str:string):string => {\r\n\treturn str.replace(/[\\\\\"']/g, '\\\\$&');\r\n};\r\n\r\n/**\r\n *\r\n */\r\nexport const append = ( parent:Element|DocumentFragment, node: string|Node|null|undefined ):void =>{\r\n\tif( node ) parent.append(node);\r\n};\r\n","/*! @orchidjs/unicode-variants | https://github.com/orchidjs/unicode-variants | Apache License (v2) */\nimport { toArray, setToPattern, escape_regex, arrayToPattern, sequencePattern } from './regex.js';\nexport { escape_regex } from './regex.js';\nimport { allSubstrings } from './strings.js';\n\n/**\n * @typedef {{[key:string]:string}} TUnicodeMap\n * @typedef {{[key:string]:Set<string>}} TUnicodeSets\n * @typedef {[[number,number]]} TCodePoints\n * @typedef {{folded:string,composed:string,code_point:number}} TCodePointObj\n * @typedef {{start:number,end:number,length:number,substr:string}} TSequencePart\n */\n/** @type {TCodePoints} */\n\nconst code_points = [[0, 65535]];\nconst accent_pat = '[\\u0300-\\u036F\\u{b7}\\u{2be}\\u{2bc}]';\n/** @type {TUnicodeMap} */\n\nlet unicode_map;\n/** @type {RegExp} */\n\nlet multi_char_reg;\nconst max_char_length = 3;\n/** @type {TUnicodeMap} */\n\nconst latin_convert = {};\n/** @type {TUnicodeMap} */\n\nconst latin_condensed = {\n  '/': '⁄∕',\n  '0': '߀',\n  \"a\": \"ⱥɐɑ\",\n  \"aa\": \"ꜳ\",\n  \"ae\": \"æǽǣ\",\n  \"ao\": \"ꜵ\",\n  \"au\": \"ꜷ\",\n  \"av\": \"ꜹꜻ\",\n  \"ay\": \"ꜽ\",\n  \"b\": \"ƀɓƃ\",\n  \"c\": \"ꜿƈȼↄ\",\n  \"d\": \"đɗɖᴅƌꮷԁɦ\",\n  \"e\": \"ɛǝᴇɇ\",\n  \"f\": \"ꝼƒ\",\n  \"g\": \"ǥɠꞡᵹꝿɢ\",\n  \"h\": \"ħⱨⱶɥ\",\n  \"i\": \"ɨı\",\n  \"j\": \"ɉȷ\",\n  \"k\": \"ƙⱪꝁꝃꝅꞣ\",\n  \"l\": \"łƚɫⱡꝉꝇꞁɭ\",\n  \"m\": \"ɱɯϻ\",\n  \"n\": \"ꞥƞɲꞑᴎлԉ\",\n  \"o\": \"øǿɔɵꝋꝍᴑ\",\n  \"oe\": \"œ\",\n  \"oi\": \"ƣ\",\n  \"oo\": \"ꝏ\",\n  \"ou\": \"ȣ\",\n  \"p\": \"ƥᵽꝑꝓꝕρ\",\n  \"q\": \"ꝗꝙɋ\",\n  \"r\": \"ɍɽꝛꞧꞃ\",\n  \"s\": \"ßȿꞩꞅʂ\",\n  \"t\": \"ŧƭʈⱦꞇ\",\n  \"th\": \"þ\",\n  \"tz\": \"ꜩ\",\n  \"u\": \"ʉ\",\n  \"v\": \"ʋꝟʌ\",\n  \"vy\": \"ꝡ\",\n  \"w\": \"ⱳ\",\n  \"y\": \"ƴɏỿ\",\n  \"z\": \"ƶȥɀⱬꝣ\",\n  \"hv\": \"ƕ\"\n};\n\nfor (let latin in latin_condensed) {\n  let unicode = latin_condensed[latin] || '';\n\n  for (let i = 0; i < unicode.length; i++) {\n    let char = unicode.substring(i, i + 1);\n    latin_convert[char] = latin;\n  }\n}\n\nconst convert_pat = new RegExp(Object.keys(latin_convert).join('|') + '|' + accent_pat, 'gu');\n/**\n * Initialize the unicode_map from the give code point ranges\n *\n * @param {TCodePoints=} _code_points\n */\n\nconst initialize = _code_points => {\n  if (unicode_map !== undefined) return;\n  unicode_map = generateMap(_code_points || code_points);\n};\n/**\n * Helper method for normalize a string\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize\n * @param {string} str\n * @param {string} form\n */\n\nconst normalize = (str, form = 'NFKD') => str.normalize(form);\n/**\n * Remove accents without reordering string\n * calling str.normalize('NFKD') on \\u{594}\\u{595}\\u{596} becomes \\u{596}\\u{594}\\u{595}\n * via https://github.com/krisk/Fuse/issues/133#issuecomment-318692703\n * @param {string} str\n * @return {string}\n */\n\nconst asciifold = str => {\n  return toArray(str).reduce(\n  /**\n   * @param {string} result\n   * @param {string} char\n   */\n  (result, char) => {\n    return result + _asciifold(char);\n  }, '');\n};\n/**\n * @param {string} str\n * @return {string}\n */\n\nconst _asciifold = str => {\n  str = normalize(str).toLowerCase().replace(convert_pat, (\n  /** @type {string} */\n  char) => {\n    return latin_convert[char] || '';\n  }); //return str;\n\n  return normalize(str, 'NFC');\n};\n/**\n * Generate a list of unicode variants from the list of code points\n * @param {TCodePoints} code_points\n * @yield {TCodePointObj}\n */\n\nfunction* generator(code_points) {\n  for (const [code_point_min, code_point_max] of code_points) {\n    for (let i = code_point_min; i <= code_point_max; i++) {\n      let composed = String.fromCharCode(i);\n      let folded = asciifold(composed);\n\n      if (folded == composed.toLowerCase()) {\n        continue;\n      } // skip when folded is a string longer than 3 characters long\n      // bc the resulting regex patterns will be long\n      // eg:\n      // folded صلى الله عليه وسلم length 18 code point 65018\n      // folded جل جلاله length 8 code point 65019\n\n\n      if (folded.length > max_char_length) {\n        continue;\n      }\n\n      if (folded.length == 0) {\n        continue;\n      }\n\n      yield {\n        folded: folded,\n        composed: composed,\n        code_point: i\n      };\n    }\n  }\n}\n/**\n * Generate a unicode map from the list of code points\n * @param {TCodePoints} code_points\n * @return {TUnicodeSets}\n */\n\nconst generateSets = code_points => {\n  /** @type {{[key:string]:Set<string>}} */\n  const unicode_sets = {};\n  /**\n   * @param {string} folded\n   * @param {string} to_add\n   */\n\n  const addMatching = (folded, to_add) => {\n    /** @type {Set<string>} */\n    const folded_set = unicode_sets[folded] || new Set();\n    const patt = new RegExp('^' + setToPattern(folded_set) + '$', 'iu');\n\n    if (to_add.match(patt)) {\n      return;\n    }\n\n    folded_set.add(escape_regex(to_add));\n    unicode_sets[folded] = folded_set;\n  };\n\n  for (let value of generator(code_points)) {\n    addMatching(value.folded, value.folded);\n    addMatching(value.folded, value.composed);\n  }\n\n  return unicode_sets;\n};\n/**\n * Generate a unicode map from the list of code points\n * ae => (?:(?:ae|Æ|Ǽ|Ǣ)|(?:A|Ⓐ|Ａ...)(?:E|ɛ|Ⓔ...))\n *\n * @param {TCodePoints} code_points\n * @return {TUnicodeMap}\n */\n\nconst generateMap = code_points => {\n  /** @type {TUnicodeSets} */\n  const unicode_sets = generateSets(code_points);\n  /** @type {TUnicodeMap} */\n\n  const unicode_map = {};\n  /** @type {string[]} */\n\n  let multi_char = [];\n\n  for (let folded in unicode_sets) {\n    let set = unicode_sets[folded];\n\n    if (set) {\n      unicode_map[folded] = setToPattern(set);\n    }\n\n    if (folded.length > 1) {\n      multi_char.push(escape_regex(folded));\n    }\n  }\n\n  multi_char.sort((a, b) => b.length - a.length);\n  const multi_char_patt = arrayToPattern(multi_char);\n  multi_char_reg = new RegExp('^' + multi_char_patt, 'u');\n  return unicode_map;\n};\n/**\n * Map each element of an array from it's folded value to all possible unicode matches\n * @param {string[]} strings\n * @param {number} min_replacement\n * @return {string}\n */\n\nconst mapSequence = (strings, min_replacement = 1) => {\n  let chars_replaced = 0;\n  strings = strings.map(str => {\n    if (unicode_map[str]) {\n      chars_replaced += str.length;\n    }\n\n    return unicode_map[str] || str;\n  });\n\n  if (chars_replaced >= min_replacement) {\n    return sequencePattern(strings);\n  }\n\n  return '';\n};\n/**\n * Convert a short string and split it into all possible patterns\n * Keep a pattern only if min_replacement is met\n *\n * 'abc'\n * \t\t=> [['abc'],['ab','c'],['a','bc'],['a','b','c']]\n *\t\t=> ['abc-pattern','ab-c-pattern'...]\n *\n *\n * @param {string} str\n * @param {number} min_replacement\n * @return {string}\n */\n\nconst substringsToPattern = (str, min_replacement = 1) => {\n  min_replacement = Math.max(min_replacement, str.length - 1);\n  return arrayToPattern(allSubstrings(str).map(sub_pat => {\n    return mapSequence(sub_pat, min_replacement);\n  }));\n};\n/**\n * Convert an array of sequences into a pattern\n * [{start:0,end:3,length:3,substr:'iii'}...] => (?:iii...)\n *\n * @param {Sequence[]} sequences\n * @param {boolean} all\n */\n\nconst sequencesToPattern = (sequences, all = true) => {\n  let min_replacement = sequences.length > 1 ? 1 : 0;\n  return arrayToPattern(sequences.map(sequence => {\n    let seq = [];\n    const len = all ? sequence.length() : sequence.length() - 1;\n\n    for (let j = 0; j < len; j++) {\n      seq.push(substringsToPattern(sequence.substrs[j] || '', min_replacement));\n    }\n\n    return sequencePattern(seq);\n  }));\n};\n/**\n * Return true if the sequence is already in the sequences\n * @param {Sequence} needle_seq\n * @param {Sequence[]} sequences\n */\n\n\nconst inSequences = (needle_seq, sequences) => {\n  for (const seq of sequences) {\n    if (seq.start != needle_seq.start || seq.end != needle_seq.end) {\n      continue;\n    }\n\n    if (seq.substrs.join('') !== needle_seq.substrs.join('')) {\n      continue;\n    }\n\n    let needle_parts = needle_seq.parts;\n    /**\n     * @param {TSequencePart} part\n     */\n\n    const filter = part => {\n      for (const needle_part of needle_parts) {\n        if (needle_part.start === part.start && needle_part.substr === part.substr) {\n          return false;\n        }\n\n        if (part.length == 1 || needle_part.length == 1) {\n          continue;\n        } // check for overlapping parts\n        // a = ['::=','==']\n        // b = ['::','===']\n        // a = ['r','sm']\n        // b = ['rs','m']\n\n\n        if (part.start < needle_part.start && part.end > needle_part.start) {\n          return true;\n        }\n\n        if (needle_part.start < part.start && needle_part.end > part.start) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    let filtered = seq.parts.filter(filter);\n\n    if (filtered.length > 0) {\n      continue;\n    }\n\n    return true;\n  }\n\n  return false;\n};\n\nclass Sequence {\n  constructor() {\n    /** @type {TSequencePart[]} */\n    this.parts = [];\n    /** @type {string[]} */\n\n    this.substrs = [];\n    this.start = 0;\n    this.end = 0;\n  }\n  /**\n   * @param {TSequencePart|undefined} part\n   */\n\n\n  add(part) {\n    if (part) {\n      this.parts.push(part);\n      this.substrs.push(part.substr);\n      this.start = Math.min(part.start, this.start);\n      this.end = Math.max(part.end, this.end);\n    }\n  }\n\n  last() {\n    return this.parts[this.parts.length - 1];\n  }\n\n  length() {\n    return this.parts.length;\n  }\n  /**\n   * @param {number} position\n   * @param {TSequencePart} last_piece\n   */\n\n\n  clone(position, last_piece) {\n    let clone = new Sequence();\n    let parts = JSON.parse(JSON.stringify(this.parts));\n    let last_part = parts.pop();\n\n    for (const part of parts) {\n      clone.add(part);\n    }\n\n    let last_substr = last_piece.substr.substring(0, position - last_part.start);\n    let clone_last_len = last_substr.length;\n    clone.add({\n      start: last_part.start,\n      end: last_part.start + clone_last_len,\n      length: clone_last_len,\n      substr: last_substr\n    });\n    return clone;\n  }\n\n}\n/**\n * Expand a regular expression pattern to include unicode variants\n * \teg /a/ becomes /aⓐａẚàáâầấẫẩãāăằắẵẳȧǡäǟảåǻǎȁȃạậặḁąⱥɐɑAⒶＡÀÁÂẦẤẪẨÃĀĂẰẮẴẲȦǠÄǞẢÅǺǍȀȂẠẬẶḀĄȺⱯ/\n *\n * Issue:\n *  ﺊﺋ [ 'ﺊ = \\\\u{fe8a}', 'ﺋ = \\\\u{fe8b}' ]\n *\tbecomes:\tئئ [ 'ي = \\\\u{64a}', 'ٔ = \\\\u{654}', 'ي = \\\\u{64a}', 'ٔ = \\\\u{654}' ]\n *\n *\tİĲ = IIJ = ⅡJ\n *\n * \t1/2/4\n *\n * @param {string} str\n * @return {string|undefined}\n */\n\n\nconst getPattern = str => {\n  initialize();\n  str = asciifold(str);\n  let pattern = '';\n  let sequences = [new Sequence()];\n\n  for (let i = 0; i < str.length; i++) {\n    let substr = str.substring(i);\n    let match = substr.match(multi_char_reg);\n    const char = str.substring(i, i + 1);\n    const match_str = match ? match[0] : null; // loop through sequences\n    // add either the char or multi_match\n\n    let overlapping = [];\n    let added_types = new Set();\n\n    for (const sequence of sequences) {\n      const last_piece = sequence.last();\n\n      if (!last_piece || last_piece.length == 1 || last_piece.end <= i) {\n        // if we have a multi match\n        if (match_str) {\n          const len = match_str.length;\n          sequence.add({\n            start: i,\n            end: i + len,\n            length: len,\n            substr: match_str\n          });\n          added_types.add('1');\n        } else {\n          sequence.add({\n            start: i,\n            end: i + 1,\n            length: 1,\n            substr: char\n          });\n          added_types.add('2');\n        }\n      } else if (match_str) {\n        let clone = sequence.clone(i, last_piece);\n        const len = match_str.length;\n        clone.add({\n          start: i,\n          end: i + len,\n          length: len,\n          substr: match_str\n        });\n        overlapping.push(clone);\n      } else {\n        // don't add char\n        // adding would create invalid patterns: 234 => [2,34,4]\n        added_types.add('3');\n      }\n    } // if we have overlapping\n\n\n    if (overlapping.length > 0) {\n      // ['ii','iii'] before ['i','i','iii']\n      overlapping = overlapping.sort((a, b) => {\n        return a.length() - b.length();\n      });\n\n      for (let clone of overlapping) {\n        // don't add if we already have an equivalent sequence\n        if (inSequences(clone, sequences)) {\n          continue;\n        }\n\n        sequences.push(clone);\n      }\n\n      continue;\n    } // if we haven't done anything unique\n    // clean up the patterns\n    // helps keep patterns smaller\n    // if str = 'r₨㎧aarss', pattern will be 446 instead of 655\n\n\n    if (i > 0 && added_types.size == 1 && !added_types.has('3')) {\n      pattern += sequencesToPattern(sequences, false);\n      let new_seq = new Sequence();\n      const old_seq = sequences[0];\n\n      if (old_seq) {\n        new_seq.add(old_seq.last());\n      }\n\n      sequences = [new_seq];\n    }\n  }\n\n  pattern += sequencesToPattern(sequences, true);\n  return pattern;\n};\n\nexport { _asciifold, asciifold, code_points, generateMap, generateSets, generator, getPattern, initialize, mapSequence, normalize, substringsToPattern, unicode_map };\n//# sourceMappingURL=index.js.map\n","import { iterate } from \"@orchidjs/sifter/lib/utils\";\r\n\r\n/**\r\n * Return a dom element from either a dom query string, jQuery object, a dom element or html string\r\n * https://stackoverflow.com/questions/494143/creating-a-new-dom-element-from-an-html-string-using-built-in-dom-methods-or-pro/35385518#35385518\r\n *\r\n * param query should be {}\r\n */\r\nexport const getDom = (query: any): HTMLElement => {\r\n\tif (query.jquery) {\r\n\t\treturn query[0];\r\n\t}\r\n\r\n\tif (query instanceof HTMLElement) {\r\n\t\treturn query;\r\n\t}\r\n\r\n\tif (isHtmlString(query)) {\r\n\t\tvar tpl = document.createElement(\"template\");\r\n\t\ttpl.innerHTML = query.trim(); // Never return a text node of whitespace as the result\r\n\t\treturn tpl.content.firstChild as HTMLElement;\r\n\t}\r\n\r\n\treturn document.querySelector(query);\r\n};\r\n\r\nexport const isHtmlString = (arg: any): boolean => {\r\n\tif (typeof arg === \"string\" && arg.indexOf(\"<\") > -1) {\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n};\r\n\r\nexport const escapeQuery = (query: string): string => {\r\n\treturn query.replace(/['\"\\\\]/g, \"\\\\$&\");\r\n};\r\n\r\n/**\r\n * Dispatch an event\r\n *\r\n */\r\nexport const triggerEvent = (dom_el: HTMLElement, event_name: string): void => {\r\n\tvar event = document.createEvent(\"HTMLEvents\");\r\n\tevent.initEvent(event_name, true, false);\r\n\tdom_el.dispatchEvent(event);\r\n};\r\n\r\n/**\r\n * Apply CSS rules to a dom element\r\n *\r\n */\r\nexport const applyCSS = (\r\n\tdom_el: HTMLElement,\r\n\tcss: { [key: string]: string | number }\r\n): void => {\r\n\tObject.assign(dom_el.style, css);\r\n};\r\n\r\n/**\r\n * Add css classes\r\n *\r\n */\r\nexport const addClasses = (\r\n\telmts: HTMLElement | HTMLElement[],\r\n\t...classes: string[] | string[][]\r\n) => {\r\n\tvar norm_classes = classesArray(classes);\r\n\telmts = castAsArray(elmts);\r\n\r\n\telmts.map((el) => {\r\n\t\tnorm_classes.map((cls) => {\r\n\t\t\tel.classList.add(cls);\r\n\t\t});\r\n\t});\r\n};\r\n\r\n/**\r\n * Remove css classes\r\n *\r\n */\r\nexport const removeClasses = (\r\n\telmts: HTMLElement | HTMLElement[],\r\n\t...classes: string[] | string[][]\r\n) => {\r\n\tvar norm_classes = classesArray(classes);\r\n\telmts = castAsArray(elmts);\r\n\r\n\telmts.map((el) => {\r\n\t\tnorm_classes.map((cls) => {\r\n\t\t\tel.classList.remove(cls);\r\n\t\t});\r\n\t});\r\n};\r\n\r\n/**\r\n * Return arguments\r\n *\r\n */\r\nexport const classesArray = (args: string[] | string[][]): string[] => {\r\n\tvar classes: string[] = [];\r\n\titerate(args, (_classes) => {\r\n\t\tif (typeof _classes === \"string\") {\r\n\t\t\t_classes = _classes.trim().split(/[\\x09\\x0a\\x0c\\x0d\\x20]/);\r\n\t\t}\r\n\t\tif (Array.isArray(_classes)) {\r\n\t\t\tclasses = classes.concat(_classes);\r\n\t\t}\r\n\t});\r\n\r\n\treturn classes.filter(Boolean);\r\n};\r\n\r\n/**\r\n * Create an array from arg if it's not already an array\r\n *\r\n */\r\nexport const castAsArray = (arg: any): Array<any> => {\r\n\tif (!Array.isArray(arg)) {\r\n\t\targ = [arg];\r\n\t}\r\n\treturn arg;\r\n};\r\n\r\n/**\r\n * Get the closest node to the evt.target matching the selector\r\n * Stops at wrapper\r\n *\r\n */\r\nexport const parentMatch = (\r\n\ttarget: null | HTMLElement,\r\n\tselector: string,\r\n\twrapper?: HTMLElement\r\n): HTMLElement | void => {\r\n\tif (wrapper && !wrapper.contains(target)) {\r\n\t\treturn;\r\n\t}\r\n\r\n\twhile (target && target.matches) {\r\n\t\tif (target.matches(selector)) {\r\n\t\t\treturn target;\r\n\t\t}\r\n\r\n\t\ttarget = target.parentNode as HTMLElement;\r\n\t}\r\n};\r\n\r\n/**\r\n * Get the first or last item from an array\r\n *\r\n * > 0 - right (last)\r\n * <= 0 - left (first)\r\n *\r\n */\r\nexport const getTail = (\r\n\tlist: Array<any> | NodeList,\r\n\tdirection: number = 0\r\n): any => {\r\n\tif (direction > 0) {\r\n\t\treturn list[list.length - 1];\r\n\t}\r\n\r\n\treturn list[0];\r\n};\r\n\r\n/**\r\n * Return true if an object is empty\r\n *\r\n */\r\nexport const isEmptyObject = (obj: object): boolean => {\r\n\treturn Object.keys(obj).length === 0;\r\n};\r\n\r\n/**\r\n * Get the index of an element amongst sibling nodes of the same type\r\n *\r\n */\r\nexport const nodeIndex = (el: null | Element, amongst?: string): number => {\r\n\tif (!el) return -1;\r\n\r\n\tamongst = amongst || el.nodeName;\r\n\r\n\tvar i = 0;\r\n\twhile ((el = el.previousElementSibling)) {\r\n\t\tif (el.matches(amongst)) {\r\n\t\t\ti++;\r\n\t\t}\r\n\t}\r\n\treturn i;\r\n};\r\n\r\n/**\r\n * Set attributes of an element\r\n *\r\n */\r\nexport const setAttr = (\r\n\tel: Element,\r\n\tattrs: { [key: string]: null | string | number }\r\n) => {\r\n\titerate(attrs, (val, attr) => {\r\n\t\tif (val == null) {\r\n\t\t\tel.removeAttribute(attr as string);\r\n\t\t} else {\r\n\t\t\tel.setAttribute(attr as string, \"\" + val);\r\n\t\t}\r\n\t});\r\n};\r\n\r\n/**\r\n * Replace a node\r\n */\r\nexport const replaceNode = (existing: Node, replacement: Node) => {\r\n\tif (existing.parentNode)\r\n\t\texisting.parentNode.replaceChild(replacement, existing);\r\n};\r\n","/**\r\n * Plugin: \"checkbox_options\" (Tom Select)\r\n * Copyright (c) contributors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this\r\n * file except in compliance with the License. You may obtain a copy of the License at:\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\r\n * ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n *\r\n */\r\n\r\nimport TomSelect from '../../tom-select';\r\nimport { preventDefault, hash_key } from '../../utils';\r\nimport { getDom } from '../../vanilla';\r\nimport { CBOptions } from './types';\r\n\r\n\r\nexport default function(this:TomSelect, userOptions:CBOptions) {\r\n\tvar self = this;\r\n\tvar orig_onOptionSelect = self.onOptionSelect;\r\n\r\n\tself.settings.hideSelected = false;\r\n\r\n\tconst cbOptions : CBOptions = Object.assign({\r\n\t\t// so that the user may add different ones as well\r\n\t\tclassName             : \"tomselect-checkbox\",\r\n\r\n\t\t// the following default to the historic plugin's values\r\n\t\tcheckedClassNames     : undefined,\r\n\t\tuncheckedClassNames   : undefined,\r\n\t}, userOptions);\r\n\r\n\r\n\tvar UpdateChecked = function(checkbox:HTMLInputElement, toCheck : boolean) {\r\n\t\tif( toCheck ){\r\n\t\t\tcheckbox.checked = true;\r\n\t\t\tif (cbOptions.uncheckedClassNames) {\r\n\t\t\t\tcheckbox.classList.remove(...cbOptions.uncheckedClassNames);\r\n\t\t\t}\r\n\t\t\tif (cbOptions.checkedClassNames) {\r\n\t\t\t\tcheckbox.classList.add(...cbOptions.checkedClassNames);\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tcheckbox.checked = false;\r\n\t\t\tif (cbOptions.checkedClassNames) {\r\n\t\t\t\tcheckbox.classList.remove(...cbOptions.checkedClassNames);\r\n\t\t\t}\r\n\t\t\tif (cbOptions.uncheckedClassNames) {\r\n\t\t\t\tcheckbox.classList.add(...cbOptions.uncheckedClassNames);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// update the checkbox for an option\r\n\tvar UpdateCheckbox = function(option:HTMLElement){\r\n\t\tsetTimeout(()=>{\r\n\t\t\tvar checkbox = option.querySelector('input.' + cbOptions.className);\r\n\t\t\tif( checkbox instanceof HTMLInputElement ){\r\n\t\t\t\tUpdateChecked(checkbox, option.classList.contains('selected'));\r\n\t\t\t}\r\n\t\t},1);\r\n\t};\r\n\r\n\t// add checkbox to option template\r\n\tself.hook('after','setupTemplates',() => {\r\n\r\n\t\tvar orig_render_option = self.settings.render.option;\r\n\r\n\t\tself.settings.render.option = (data, escape_html) => {\r\n\t\t\tvar rendered = getDom(orig_render_option.call(self, data, escape_html));\r\n\t\t\tvar checkbox = document.createElement('input');\r\n\t\t\tif (cbOptions.className) {\r\n\t\t\t\tcheckbox.classList.add(cbOptions.className);\r\n\t\t\t}\r\n\t\t\tcheckbox.addEventListener('click',function(evt){\r\n\t\t\t\tpreventDefault(evt);\r\n\t\t\t});\r\n\r\n\t\t\tcheckbox.type = 'checkbox';\r\n\t\t\tconst hashed = hash_key(data[self.settings.valueField]);\r\n\r\n\t\t\tUpdateChecked(checkbox, !!(hashed && self.items.indexOf(hashed) > -1) );\r\n\r\n\t\t\trendered.prepend(checkbox);\r\n\t\t\treturn rendered;\r\n\t\t};\r\n\t});\r\n\r\n\t// uncheck when item removed\r\n\tself.on('item_remove',(value:string) => {\r\n\t\tvar option = self.getOption(value);\r\n\r\n\t\tif( option ){ // if dropdown hasn't been opened yet, the option won't exist\r\n\t\t\toption.classList.remove('selected'); // selected class won't be removed yet\r\n\t\t\tUpdateCheckbox(option);\r\n\t\t}\r\n\t});\r\n\r\n\t// check when item added\r\n\tself.on('item_add',(value:string) => {\r\n\t\tvar option = self.getOption(value);\r\n\r\n\t\tif( option ){ // if dropdown hasn't been opened yet, the option won't exist\r\n\t\t\tUpdateCheckbox(option);\r\n\t\t}\r\n\t});\r\n\r\n\r\n\t// remove items when selected option is clicked\r\n\tself.hook('instead','onOptionSelect',( evt:KeyboardEvent, option:HTMLElement )=>{\r\n\r\n\t\tif( option.classList.contains('selected') ){\r\n\t\t\toption.classList.remove('selected')\r\n\t\t\tself.removeItem(option.dataset.value);\r\n\t\t\tself.refreshOptions();\r\n\t\t\tpreventDefault(evt,true);\r\n\t\t\treturn;\r\n        }\r\n\r\n\t\torig_onOptionSelect.call(self, evt, option);\r\n\r\n\t\tUpdateCheckbox(option);\r\n\t});\r\n\r\n};\r\n"],"names":["hash_key","value","get_hash","preventDefault","evt","stop","stopPropagation","getDom","query","jquery","HTMLElement","isHtmlString","tpl","document","createElement","innerHTML","trim","content","firstChild","querySelector","arg","indexOf","userOptions","self","orig_onOptionSelect","onOptionSelect","settings","hideSelected","cbOptions","Object","assign","className","checkedClassNames","undefined","uncheckedClassNames","UpdateChecked","checkbox","toCheck","checked","classList","remove","add","UpdateCheckbox","option","setTimeout","HTMLInputElement","contains","hook","orig_render_option","render","data","escape_html","rendered","call","addEventListener","type","hashed","valueField","items","prepend","on","getOption","removeItem","dataset","refreshOptions"],"mappings":"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","x_google_ignoreList":[1]}